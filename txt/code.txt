* miniC- Compilation to MC Code
* Standard prelude:
  0:     LD  6,0(0) 	load maxaddress from location 0
  1:     ST  0,0(0) 	clear location 0
  2:    LDA  4,0(6) 	copy gp to sp & allocating global variables(if any)
* End of standard prelude.
* Jump to main()
* Begin output()
  9:     LD  1,1(4) 	load param into ax
 10:    OUT  1,0,0 	output using ax
 11:    LDA  4,1(4) 	pop prepare
 12:     LD  7,-1(4) 	pop return addr
* End output()
* -> function:
 13:    LDA  4,-1(4) 	push prepare
 14:     ST  5,0(4) 	push old bp
 15:    LDA  5,0(4) 	let bp == sp
 16:    LDA  4,-2(4) 	allocate for local variables
* -> compound
* -> assign
* -> Id
 17:    LDA  2,-1(5) 	get local address
* <- Id
 18:    LDA  4,-1(4) 	push prepare
 19:     ST  2,0(4) 	protect bx
* -> Const
 20:    LDC  1,10(0) 	load const
* <- Const
 21:    LDA  4,1(4) 	pop prepare
 22:     LD  2,-1(4) 	recover bx
 23:     ST  1,0(2) 	assign: store
* <- assign
* -> assign
* -> Id
 24:    LDA  2,-2(5) 	get local address
* <- Id
 25:    LDA  4,-1(4) 	push prepare
 26:     ST  2,0(4) 	protect bx
* -> Const
 27:    LDC  1,3(0) 	load const
* <- Const
 28:    LDA  4,1(4) 	pop prepare
 29:     LD  2,-1(4) 	recover bx
 30:     ST  1,0(2) 	assign: store
* <- assign
* -> while
* jump here after body
* -> Op
* -> Id
 31:    LDA  2,-2(5) 	get local address
 32:     LD  1,0(2) 	get variable value
* <- Id
 33:    LDA  4,-1(4) 	push prepare
 34:     ST  1,0(4) 	op: protect left
* -> Const
 35:    LDC  1,0(0) 	load const
* <- Const
 36:    LDA  4,1(4) 	pop prepare
 37:     LD  2,-1(4) 	op: recover left
 38:    SUB  1,2,1 	op >
 39:    JGT  1,2(7) 	br if true
 40:    LDC  1,0(0) 	false case
 41:    LDA  7,1(7) 	unconditional jmp
 42:    LDC  1,1(0) 	true case
* <- Op
* jump to end if test fails
* -> compound
* -> assign
* -> Id
 44:    LDA  2,-2(5) 	get local address
* <- Id
 45:    LDA  4,-1(4) 	push prepare
 46:     ST  2,0(4) 	protect bx
* -> Op
* -> Id
 47:    LDA  2,-2(5) 	get local address
 48:     LD  1,0(2) 	get variable value
* <- Id
 49:    LDA  4,-1(4) 	push prepare
 50:     ST  1,0(4) 	op: protect left
* -> Const
 51:    LDC  1,1(0) 	load const
* <- Const
 52:    LDA  4,1(4) 	pop prepare
 53:     LD  2,-1(4) 	op: recover left
 54:    SUB  1,2,1 	op -
* <- Op
 55:    LDA  4,1(4) 	pop prepare
 56:     LD  2,-1(4) 	recover bx
 57:     ST  1,0(2) 	assign: store
* <- assign
* -> assign
* -> Id
 58:    LDA  2,-1(5) 	get local address
* <- Id
 59:    LDA  4,-1(4) 	push prepare
 60:     ST  2,0(4) 	protect bx
* -> Op
* -> Id
 61:    LDA  2,-1(5) 	get local address
 62:     LD  1,0(2) 	get variable value
* <- Id
 63:    LDA  4,-1(4) 	push prepare
 64:     ST  1,0(4) 	op: protect left
* -> Const
 65:    LDC  1,1(0) 	load const
* <- Const
 66:    LDA  4,1(4) 	pop prepare
 67:     LD  2,-1(4) 	op: recover left
 68:    ADD  1,2,1 	op +
* <- Op
 69:    LDA  4,1(4) 	pop prepare
 70:     LD  2,-1(4) 	recover bx
 71:     ST  1,0(2) 	assign: store
* <- assign
* <- compound
 72:    LDA  7,31(0) 	jump to test
 43:    JEQ  1,73(0) 	jump to end
* <- while
* -> call
* -> Id
 73:    LDA  2,-1(5) 	get local address
 74:     LD  1,0(2) 	get variable value
* <- Id
 75:    LDA  4,-1(4) 	push prepare
 76:     ST  1,0(4) 	push parameters
 77:    LDA  1,3(7) 	store returned PC
 78:    LDA  4,-1(4) 	push prepare
 79:     ST  1,0(4) 	push returned PC
 80:    LDC  7,9(0) 	jump to function
 81:    LDA  4,1(4) 	release parameters
* <- call
* <- compound
 82:    LDA  4,0(5) 	let sp == bp
 83:    LDA  4,2(4) 	pop prepare
 84:     LD  5,-2(4) 	pop old bp
 85:     LD  7,-1(4) 	pop return addr
* <- function
  3:    LDA  1,3(7) 	store returned PC
  4:    LDA  4,-1(4) 	push prepare
  5:     ST  1,0(4) 	push returned PC
  6:    LDC  7,13(0) 	jump to function
  7:    LDA  4,2(4) 	release local var
* End of execution.
  8:   HALT  0,0,0 	
